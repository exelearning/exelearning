/**
 * plugin.min.js
 *
 * Released under Attribution-ShareAlike 4.0 International License.
 * Author: Sdweb (http://www.sdweb.es/) for BirtLH (http://www.ulhi.hezkuntza.net/)
 * Author: Ignacio Gros (http://gros.es/) for http://exelearning.net/
 *
 * License: http://creativecommons.org/licenses/by-sa/4.0/

 * Button icon by Google (https://material.io/tools/icons/), available under the Apache license version 2.0. (http://www.apache.org/licenses/LICENSE-2.0) 
 * The "Insert/Edit Embedded Media" icon is just part of a TinyMCE screenshot.
 */

/**
 * Record audio, include it in the package resources and create an HTML AUDIO element.
 * You can choose if you want to include a JavaScript player or not. 
 * It requires some server side actions included in eXe (see $exeAuthoring.fileUpload).
 * Original iDevice and server side code by Sdweb.
 * TinyMCE plugin by Ignacio Gros.
 */

// TinyMCE Plugin
tinymce.PluginManager.add('exeaudio', function (editor, url) {

	// Public object
	let $ = tinymce.dom.DomQuery;
	let actualInput = '';
	actualJsPlayer = false;

	function getInitialData() {
		let data = {
			exeAudioInput: actualInput,
			jsplayer: actualJsPlayer
		}

		return data;
	}

	function setIds() {
		let divMain = $('div.tox-form').eq(0);

		let divFirstLine = divMain.children().eq(0);
		tinymce.DOM.removeClass(divFirstLine, 'tox-form__grid tox-form__grid--2col');
		tinymce.DOM.addClass(divFirstLine, 'tox-form__group');
		tinymce.DOM.setStyles(divFirstLine, { 'display': 'flex' });

		let labelInputContainer = divFirstLine.children().eq(0);
		tinymce.DOM.setStyles(labelInputContainer, { 'min-width': 120, 'padding': '8px 0' });
		let labelInput = labelInputContainer.children().eq(0);
		tinymce.DOM.setAttrib(labelInput, 'for', 'EAR_inputDevices');


		let divInputDevice = $('div.tox-listboxfield').eq(0);
		tinymce.DOM.setAttribs(divInputDevice, { id: 'EAR_inputDevices' });
		tinymce.DOM.setStyles(divInputDevice, { 'min-width': 150 });

		let divAudioRecorder = divMain.children().eq(1).children().eq(0);
		tinymce.DOM.setAttrib(divAudioRecorder, 'id', 'exeAudioRecorder');

		let divWrapperRecorder = divMain.children().eq(1).children().eq(1);
		tinymce.DOM.setAttrib(divWrapperRecorder, 'id', 'EAR_record');

		let divButtonRecorder = divWrapperRecorder.children().eq(0);
		tinymce.DOM.setAttrib(divButtonRecorder, 'id', 'EAR_record-button');

		let divWrapperSave = divMain.children().eq(1).children().eq(2)
		tinymce.DOM.setAttrib(divWrapperSave, 'id', 'EAR_save');

		let divButtonSave = divWrapperSave.children().eq(0);
		tinymce.DOM.setAttrib(divButtonSave, 'id', 'EAR_save-button');

		let divAudioViewer = divMain.children().eq(1).children().eq(3);
		tinymce.DOM.setAttrib(divAudioViewer, 'id', 'exeAudioViewer');

		let divAudioInstructions = divMain.children().eq(3);
		tinymce.DOM.setAttrib(divAudioInstructions, 'id', 'exeAudioInstructions');

		let html = tinymce.DOM.getOuterHTML(divWrapperRecorder);
		html = html.replace('div', 'span');
		tinymce.DOM.setOuterHTML(divWrapperRecorder, html);

		html = tinymce.DOM.getOuterHTML(divWrapperSave);
		html = html.replace('div', 'span');
		tinymce.DOM.setOuterHTML(divWrapperSave, html);
	}

	var eXeAudioRecorder = {

		setDefaultValues: function () {
			actualInput = '';
			actualJsPlayer = false;
		},

		// Tell the user how to complete the audio information
		getInstructions: function () {
			var alt = _("Insert\/Edit Embedded Media");
			var str = _("Use the %s option after recording to define the authorship or title of the audio.");
			str = str.replace('%s', '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm4.8 2.6l5.6 4a.5.5 0 010 .8l-5.6 4A.5.5 0 019 16V8a.5.5 0 01.8-.4z" fill-rule="nonzero"/></svg>');
			return str;
		},

		// Get browser name and version
		browserSpecs: function () {
			var ua = navigator.userAgent, tem,
				M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
			if (/trident/i.test(M[1])) {
				tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
				return { name: 'IE', version: (tem[1] || '') };
			}
			if (M[1] === 'Chrome') {
				tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
				if (tem != null) return { name: tem[1].replace('OPR', 'Opera'), version: tem[2] };
			}
			M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
			if ((tem = ua.match(/version\/(\d+)/i)) != null)
				M.splice(1, 1, tem[1]);
			return { name: M[0], version: M[1] };
		},

		// Check browser compatibility
		// MediaRecorder is supported by Chrome 49+, Firefox 30+, Opera 36+, Android Webview 47+ (not by IE)
		checkCompatibility: function () {
			var compatibility = false;
			var browser = this.browserSpecs();
			if (browser.name == "Chrome" && browser.version >= 49) {
				compatibility = true;
			} else if (browser.name == "Firefox" && browser.version >= 65) {
				compatibility = true;
			} else if (browser.name == "Opera" && browser.version >= 36) {
				compatibility = true;
			}
			return compatibility;
		},

		// Avoid devices long names
		truncateDeviceName: function (str) {
			var n = 65;
			return (str.length > n) ? str.substr(0, n - 1) + '...' : str;
		},

		// Get the audio input devices (right after loading TinyMCE)
		checkDevices: function () {
			eXeAudioRecorder.devices = [];
			eXeAudioRecorder.devices.control = [];
			if (navigator.mediaDevices == null) return;
			navigator.mediaDevices.enumerateDevices()
				.then(function (devices) {
					devices.forEach(function (device) {
						if (device.kind == "audioinput") {
							let item = { text: device.deviceId, value: device.deviceId }
							if (device.label != "") {
								item = { text: eXeAudioRecorder.truncateDeviceName(device.label), value: device.deviceId }
							}
							if (eXeAudioRecorder.devices.control.indexOf(device.deviceId) == -1) {
								eXeAudioRecorder.devices.push(item);
								eXeAudioRecorder.devices.control.push(device.deviceId)
							}
						}
					});
				});
		},

		getJsPlayerOptionValue: function (editor) {
			var elm = editor.selection.getNode();
			var c = elm.className;
			if (c && c.indexOf("mce-preview-object ") == 0 && c.indexOf(" mce-object-audio") != -1) {
				if (elm.dataset && elm.dataset["mcePSrc"] && elm.dataset["mcePSrc"] != "") {
					// JavaScript player
					var jsplayer = elm.dataset.mcePClass;
					if (jsplayer && jsplayer.indexOf('mediaelement') != -1) {
						actualJsPlayer = true;
					}
				}
			}
		},

		// Enable the audio recorder
		enableAudioRecorder: function (editor) {
			var audioType = "audio/webm";
			var mediaRecorder;
			var audioInputId;
			var chunks = [];
			var durationSeconds = 0;
			var durationDecimals = 0;
			var timer;
			var durationField = document.getElementById("EAR_Duration")
			var bRecord = document.getElementById("EAR_record-button");
			var bSaveWrapper = document.getElementById("EAR_save");
			var bSave = document.getElementById("EAR_save-button");
			var audioField = document.getElementById('EAR_audioField');
			var menu = document.getElementById("EAR_inputDevices");
			// Timer for audio duration
			function pad(val) { return val > 9 ? val : "0" + val; }
			function setTime() {
				++durationDecimals;
				if (durationDecimals == 10) {
					++durationSeconds;
					durationDecimals = 0;
				}
				seconds = pad(durationSeconds % 60)
				minutes = pad(parseInt(durationSeconds / 60));
				durationField.innerHTML = minutes + ":" + seconds;
			}
			// Record button
			bRecord.style = RecordAudioDialog.getIcon(RecordAudioDialog.pluginURL, "record");
			bRecord.onclick = function () {
				bSaveWrapper.style.visibility = "visible";
				var audioInputId = actualInput;
				if (mediaRecorder) {
					if (bRecord.classList.contains("recording") && mediaRecorder.state == "recording") {
						mediaRecorder.pause();
						clearInterval(timer);
						bRecord.innerHTML = _("Continue");
						bRecord.style = RecordAudioDialog.getIcon(RecordAudioDialog.pluginURL, "record");
						bRecord.classList.remove("recording");
						bRecord.classList.add("pause");
					} else if (bRecord.classList.contains("pause") && mediaRecorder.state == "paused") {
						mediaRecorder.resume();
						timer = setInterval(setTime, 100);
						bRecord.innerHTML = _("Pause");
						bRecord.style = RecordAudioDialog.getIcon(RecordAudioDialog.pluginURL, "pause");
						bRecord.classList.add("recording");
					} else if (mediaRecorder.state == "inactive") {
						chunks = [];
						durationSeconds = 0;
						durationDecimals = 0;
						durationField.innerHTML = "00:00";
						initGetUserMedia(audioInputId);
					}
				} else {
					initGetUserMedia(audioInputId);
				}
			}
			// Finish button
			bSaveWrapper.style.visibility = "hidden";
			bSaveWrapper.style.borderLeft = 0;
			bSave.style = RecordAudioDialog.getIcon(RecordAudioDialog.pluginURL, "stop");
			bSave.onclick = function () {
				if (mediaRecorder) {
					mediaRecorder.stop()
					clearInterval(timer);
					bRecord.disabled = false;
					bSave.disabled = true;
					bRecord.style.color = "";
					bSaveWrapper.style.visibility = "hidden";
					bRecord.innerHTML = _("Record");
					bRecord.style = RecordAudioDialog.getIcon(RecordAudioDialog.pluginURL, "record");
					bRecord.classList.remove("recording");
				} else {
					eXe.app.alert(_("Error: Media Recorder"));
				}
			}
			// Upload audio file to /previews/
			function uploadAudioFile() {
				let blob = new Blob(chunks, { 'type': audioType });
				ext = audioType.split("/")[1];
				durationMilliseconds = durationSeconds * 1000 + durationDecimals * 100;
				ysFixWebmDuration(blob, durationMilliseconds, async function (fixedBlob) {
					fixedBlob.name = (new Date()).getTime() + Math.random().toString(36).substring(2, 15) + "." + ext;
					// $exeAuthoring.fileUpload("uploadRecordedAudio", fixedBlob, audioField);
					//new method for upload audio record

					// Uploading file without get base64 code (use this if the upload has problems with the base64 string length)
					// var fd = new FormData();
					// fd.append('file', fixedBlob);
					// fd.append('filename', [fixedBlob.name]);
					// fd.append('odeSessionId', [eXeLearning.app.project.odeSession]);
					// let response = await eXe.app.uploadLargeFile(fd);

					// Using blobToBase64
					let base64 = await blobToBase64(fixedBlob);
					let response = await eXe.app.uploadFile(base64, fixedBlob.name);

					if (response && response.savedPath && response.savedFilename) {
						let fileUrl = response.savedPath + response.savedFilename;
						audioField.src = fileUrl;
						audioField.setAttribute("controls", "controls");
						audioField.classList.add("on");
						audioField.classList.remove("off");
					}

				});
			}

			function blobToBase64(blob) {
				return new Promise((resolve, _) => {
					const reader = new FileReader();
					reader.onloadend = () => resolve(reader.result);
					reader.readAsDataURL(blob);
				});
			}

			// Init mediaDevices.getUserMedia & MediaRecord
			function initGetUserMedia(inputId) {
				navigator.mediaDevices.getUserMedia({ audio: { deviceId: inputId } })
					.then(function (stream) {
						options = { mimeType: audioType };
						mediaRecorder = new MediaRecorder(stream, options);
						bRecord.disabled = false;
						mediaRecorder.onstop = function () {
							uploadAudioFile();
						}
						mediaRecorder.ondataavailable = function (e) {
							chunks.push(e.data);
						}
						// Start recording
						mediaRecorder.start();
						timer = setInterval(setTime, 100);
						bRecord.innerHTML = _("Pause");
						bRecord.style.backgroundImage = 'url(' + RecordAudioDialog.pluginURL + '/img/controls/pause.png)';
						bRecord.classList.add("recording");
						bSave.disabled = false;
						audioField.classList.add("off");
						audioField.classList.remove("on");
						audioField.pause();
						audioField.removeAttribute("controls");
					})
					.catch(function (err) {
						eXe.app.alert(err.message);
					});
			}
			// Get the previous values (so you can overwrite an audio)
			var elm = editor.selection.getNode();
			var c = elm.className;
			if (c && c.indexOf("mce-preview-object ") == 0 && c.indexOf(" mce-object-audio") != -1) {
				if (elm.dataset && elm.dataset["mcePSrc"] && elm.dataset["mcePSrc"] != "") {
					// Load the previous values;
					$("#EAR_audioField")
						.attr("src", elm.dataset["mcePSrc"])
						.attr("controls", "")
						.addClass("on");
					// JavaScript player
					// var jsplayer = elm.dataset.mcePClass;
					// if (!jsplayer || (jsplayer && jsplayer.indexOf('mediaelement') == -1)) {
					// 	actualJsPlayer = false;
					// }
				}
			}
		}

	}

	RecordAudioDialog = {

		openDialog: function () {

			eXeAudioRecorder.setDefaultValues();

			eXeAudioRecorder.getJsPlayerOptionValue(editor);

			// Not audio input device
			if (eXeAudioRecorder.devices.length == 0) {
				eXe.app.alert(_("There is no audio input device connected."));
				return false;
			}

			// Just one input device (we call it "Default")
			if (eXeAudioRecorder.devices.length == 1) {
				eXeAudioRecorder.devices = [{ text: _("Default"), value: eXeAudioRecorder.devices[0]['value'] }]
			}

			// Open the window
			win = editor.windowManager.open({
				title: _('Audio recorder'),
				width: 650,
				height: 350,
				body: {
					type: 'panel',
					items: [
						{
							type: 'grid',
							columns: 2,
							items: [
								{
									type: 'label',
									label: _('Audio input:'),
									items: []
								},
								{
									type: 'listbox',
									name: 'exeAudioInput',
									items: eXeAudioRecorder.devices
								}
							]
						},
						{
							type: 'panel',
							id: 'exeAudioContainer',
							items: [
								{
									type: 'htmlpanel',
									html: '<p style="margin:20px 0 10px 0"><b>' + _("Duration:") + '</b> <span id="EAR_Duration">00:00</span></p>'
								},
								{
									type: 'button',
									name: 'recordAudio',
									text: _("Record")
								},
								{
									type: 'button',
									name: 'saveAudio',
									text: _("Finish")
								},
								// 	]
								// },
								{
									type: 'htmlpanel',
									html: '<div style="height:54px;margin-top:10px"><audio id="EAR_audioField" preload="metadata" style="min-height:54px;min-width:350px" controlsList="nodownload"></audio></div>'
								}
							]
						},
						{
							type: 'panel',
							items: [
								{ name: 'jsplayer', type: 'checkbox', checked: true, label: _("JavaScript player (for old browsers or browsers that can't play that audio format)") }
							]
						},
						{
							type: 'htmlpanel',
							html: '<div style="margin-top:20px">' + eXeAudioRecorder.getInstructions() + '</div>'
						}
					]
				},
				buttons: [
					{
						type: 'cancel',
						name: 'cancel',
						text: 'Cancel'
					},
					{
						type: 'submit',
						name: 'submit',
						text: 'Ok',
						primary: true
					}
				],
				initialData: getInitialData(),
				onChange: function (api, details) {
					switch (details.name) {
						case 'jsplayer':
							actualJsPlayer = api.getData().jsplayer;
							break;
						case 'exeAudioInput':
							actualInput = api.getData().exeAudioInput;
							break;
					}
				},
				onSubmit: function (api) {
					// Include JavaScript player?
					var jsPlayer = "";
					if (actualJsPlayer) {
						jsPlayer = ' class="mejs__player mediaelement"'
					};
					var audioPath = $("#EAR_audioField").attr("src");
					if (!audioPath || audioPath.indexOf("files/tmp") == -1 || audioPath.indexOf(".webm") == -1) return false;
					// Insert or update the content
					var fileName = audioPath.split("/");
					fileName = fileName[fileName.length - 1];
					var c = '<audio controls="controls" src="' + audioPath + '"' + jsPlayer + '><a href="' + audioPath + '">' + fileName + '</a></audio>'
					editor.execCommand('mceInsertContent', false, c, { skip_undo: 1 });
					editor.windowManager.close();
					return false;
				}
			});

			setIds();

			// Set dialog width
			tinymce.DOM.setStyle($('div.tox-dialog').eq(0), 'min-width', 680);

			eXeAudioRecorder.enableAudioRecorder(editor);

		}, // openDialog

		getIcon: function (url, icon) {
			return "padding-left:26px;background-image:url(" + url + "/img/controls/" + icon + ".png);background-repeat:no-repeat;background-position:6px 50%";
		}

	} // RecordAudioDialog

	// Save the plugin URL
	RecordAudioDialog.pluginURL = url;

	if (eXeAudioRecorder.checkCompatibility() == true) {

		// Plugin button
		editor.ui.registry.addIcon('exeaudio', '<svg xmlns="http://www.w3.org/2000/svg" height="16" viewBox="0 0 24 24" width="16"><circle cx="9" cy="9" r="4"/><path d="M9 15c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4zm7.76-9.64l-1.68 1.69c.84 1.18.84 2.71 0 3.89l1.68 1.69c2.02-2.02 2.02-5.07 0-7.27zM20.07 2l-1.63 1.63c2.77 3.02 2.77 7.56 0 10.74L20.07 16c3.9-3.89 3.91-9.95 0-14z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
		editor.ui.registry.addButton('exeaudio', {
			icon: "exeaudio",
			tooltip: _('Audio recorder'),
			onAction: RecordAudioDialog.openDialog
		});

		// Check the available audio input devices
		editor.on('init', function (e) {
			eXeAudioRecorder.checkDevices();
		});

	}

});